/*! jscanify v1.4.0 | (c) ColonelParrot and other contributors | MIT License */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.jscanify=t()}(this,function(){"use strict";function e(e,t){return Math.hypot(e.x-t.x,e.y-t.y)}return class{constructor(){}findPaperContour(e){const t=new cv.Mat;cv.Canny(e,t,50,200);const o=new cv.Mat;cv.GaussianBlur(t,o,new cv.Size(3,3),0,0,cv.BORDER_DEFAULT);const n=new cv.Mat;cv.threshold(o,n,0,255,cv.THRESH_OTSU);let r=new cv.MatVector,c=new cv.Mat;cv.findContours(n,r,c,cv.RETR_CCOMP,cv.CHAIN_APPROX_SIMPLE);let a=0,i=-1;for(let e=0;e<r.size();++e){let t=cv.contourArea(r.get(e));t>a&&(a=t,i=e)}const l=i>=0?r.get(i):null;return t.delete(),o.delete(),n.delete(),r.delete(),c.delete(),l}highlightPaper(e,t){(t=t||{}).color=t.color||"orange",t.thickness=t.thickness||10,t.background=t.background||"rgba(0, 255, 0, 0.2)";const o=document.createElement("canvas"),n=o.getContext("2d"),r=cv.imread(e),c=this.findPaperContour(r);if(cv.imshow(o,r),c){const{topLeftCorner:e,topRightCorner:o,bottomLeftCorner:a,bottomRightCorner:i}=this.getCornerPoints(c,r);e&&o&&a&&i&&(n.fillStyle=t.background,n.beginPath(),n.moveTo(...Object.values(e)),n.lineTo(...Object.values(o)),n.lineTo(...Object.values(i)),n.lineTo(...Object.values(a)),n.closePath(),n.fill(),n.strokeStyle=t.color,n.lineWidth=t.thickness,n.beginPath(),n.moveTo(...Object.values(e)),n.lineTo(...Object.values(o)),n.lineTo(...Object.values(i)),n.lineTo(...Object.values(a)),n.lineTo(...Object.values(e)),n.stroke())}return r.delete(),o}extractPaper(e,t,o,n){const r=document.createElement("canvas"),c=cv.imread(e),a=n?null:this.findPaperContour(c);if(null==a&&void 0===n)return null;const{topLeftCorner:i,topRightCorner:l,bottomLeftCorner:s,bottomRightCorner:v}=n||this.getCornerPoints(a,c);let u=new cv.Mat,d=new cv.Size(t,o),f=cv.matFromArray(4,1,cv.CV_32FC2,[i.x,i.y,l.x,l.y,s.x,s.y,v.x,v.y]),C=cv.matFromArray(4,1,cv.CV_32FC2,[0,0,t,0,0,o,t,o]),h=cv.getPerspectiveTransform(f,C);return cv.warpPerspective(c,u,h,d,cv.INTER_LINEAR,cv.BORDER_CONSTANT,new cv.Scalar),cv.imshow(r,u),c.delete(),u.delete(),r}getCornerPoints(t){const o=cv.minAreaRect(t).center;let n,r,c,a,i=0,l=0,s=0,v=0;for(let u=0;u<t.data32S.length;u+=2){const d={x:t.data32S[u],y:t.data32S[u+1]},f=e(d,o);d.x<o.x&&d.y<o.y?f>i&&(n=d,i=f):d.x>o.x&&d.y<o.y?f>l&&(r=d,l=f):d.x<o.x&&d.y>o.y?f>s&&(c=d,s=f):d.x>o.x&&d.y>o.y&&f>v&&(a=d,v=f)}return{topLeftCorner:n,topRightCorner:r,bottomLeftCorner:c,bottomRightCorner:a}}}});